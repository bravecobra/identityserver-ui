{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This project provides a more complete web interface, but still based on the quick-start UI for Identity Server 4.</p> <p>The <code>docker-compose</code> setup puts the Identity Server (STS), API's and any clients behind a reverse-proxy (nginx) and offers SSL-termination at the proxy.</p> <p></p>"},{"location":"#running-documentation-through-docker","title":"Running documentation through docker","text":"<pre><code>docker build -t docs  -f .\\src\\docs\\Dockerfile .\ndocker run -p 8080:8080 docs\n</code></pre> <p>You can now access this documentation from localhost:8080.</p>"},{"location":"license/","title":"MIT License","text":"<p>Copyright (c) 2020 Giovanni Van Geel</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"setup/docker-compose/","title":"Docker-compose","text":"<p>Make you also completes the other prerequisites</p>"},{"location":"setup/docker-compose/#build-the-images","title":"Build the images","text":"<p>Now that everything resolves well, we have the certificates and we configured a Google OAuth client, we start up <code>docker-compose</code>. The building of the docker images is left in in this setup to make it easy enough to start this up.</p> <pre><code>docker-compose build\n</code></pre>"},{"location":"setup/docker-compose/#run-the-images","title":"Run the images","text":"<pre><code>docker-compose up -d\n</code></pre>"},{"location":"setup/docker-compose/#test-it-out","title":"Test it out","text":"<p>Now point your browser to https://sts.localhost.com to reach the IdentityServer itself and login. Or use one of the two preconfigured clients at https://jsclient.localhost.com or https://mvcclient.localhost.com.</p>"},{"location":"setup/kubernetes/","title":"Setup Kubernetes","text":""},{"location":"setup/kubernetes/#prepare-the-cluster","title":"Prepare the cluster","text":"<p>I use on Docker Desktop <code>2.2.0.5</code> which comes with Kubernetes <code>1.15.5</code> on Windows and Mac. Testing has only been done on Windows.</p> <p>Make you also completes the other prerequisites</p>"},{"location":"setup/kubernetes/#metallb","title":"MetalLB","text":"<p>If you're not on a hosted cluster (like GCE, AKS, EKS or DigitialOcean), you'll want to provide a load-balancing implementation in order to have external-ip assigned automatically. I used MetalLB for this on my 1-node local cluster</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.3/manifests/namespace.yaml\nkubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.9.3/manifests/metallb.yaml\n</code></pre> <p>if, for some reason, you get the error that the memberlist secret does not exist, create it manually:</p> <pre><code>kubectl create secret generic -n metallb-system memberlist --from-literal=secretkey=\"$(openssl rand -base64 128)\"\n</code></pre>"},{"location":"setup/kubernetes/#tiller-2x","title":"Tiller (2.x)","text":"<p>As we use helm to install the nginx-ingress, we'll need to have it installed on our cluster.</p> <pre><code>helm repo add stable https://kubernetes-charts.storage.googleapis.com/\nhelm repo update\nkubectl apply -f ./k8s/infrastructure/tiller/rbac-config.yaml\nkubectl apply -f ./k8s/infrastructure/tiller/tiller.yaml\n</code></pre>"},{"location":"setup/kubernetes/#build-the-docker-images","title":"Build the docker images","text":"<p>We need to make sure we build the latest images. We'll use <code>docker-compose</code> to do that easily.</p> <pre><code>docker-compose build\n</code></pre>"},{"location":"setup/kubernetes/#deploy-to-the-cluster","title":"Deploy to the cluster","text":""},{"location":"setup/kubernetes/#create-a-new-namespace","title":"Create a new namespace","text":"<p>Run the following command to create a new namespace called <code>identityserver-ui</code></p> <pre><code>kubectl apply -f ./k8s/infrastructure/namespace.yaml\n</code></pre>"},{"location":"setup/kubernetes/#sql-server","title":"SQL Server","text":""},{"location":"setup/kubernetes/#change-the-default-password","title":"Change the default password","text":"<p>Create a k8s secret for SQL server by first base64 encoding the actual password in powershell or bash, depending on you OS:</p> <pre><code>[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(\"Password_123\"))\n</code></pre> <p>or</p> <pre><code>echo -n 'Password_123' | base64\n</code></pre> <p>Storing a secret as a base64-encoded string is not secure! This is neither hashing or encryption.</p> <p>Edit the <code>sqlserverdb-deployment.yaml</code> if you want another password or override it with:</p> <pre><code>kubectl create secret generic sqlserverdb --namespace=identityserver-ui --from-literal=sa_password=Password_123\n</code></pre> <p>Now deploy the SQL Server onto your kubernetes cluster in the new namespace</p>"},{"location":"setup/kubernetes/#deploy-sqlserver","title":"Deploy SQLServer","text":"<pre><code>kubectl apply -f ./k8s/services/sqlserverdb-deployment.yaml\n</code></pre>"},{"location":"setup/kubernetes/#create-the-ca-certificate-configmap","title":"Create the CA Certificate ConfigMap","text":"<p>First add the CA Root certificate as a ConfigMap, that was created during the certificates setup.</p> <pre><code>kubectl create configmap ca-pemstore --from-file=./compose/nginx/certs/cacerts.pem --namespace=identityserver-ui\n</code></pre> <p>That way we can mount the CA Root certificate into our services as a configmap (as adding an extra file)</p>"},{"location":"setup/kubernetes/#deploy-sts","title":"Deploy STS","text":"<p>Create a config map from the <code>SeedData.json</code> file so we can use in the sts service.</p> <pre><code>kubectl create configmap seeddata --from-file=./compose/sts/SeedData.json --namespace=identityserver-ui\n</code></pre> <p>Next we want to store the db connection string as a secret as well:</p> <pre><code>[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(\"Server=sqlserverdb-svc;Database=IdentityUI;User Id=sa;Password=Password_123;MultipleActiveResultSets=true\"))\n</code></pre> <p>Storing a secret as a base64-encoded string is not secure. This is neither hashing or encryption.</p> <p>Grab the output and store that in <code>sts-deployment.yml</code> file as a secret called <code>sts-dbconnection</code> (already done with the above connectionstring). The secret is referenced in the deployment later.</p> <p>The google credentials are referenced from yet another secret Create a file called <code>google-data.yml</code> in <code>./k8s/services</code> that looks like this:</p> <pre><code>kind: Secret\napiVersion: v1\nmetadata:\n  name: sts-google\n  namespace: identityserver-ui\ndata:\n  Google_ClientId: &lt;output from your base64 encoded ClientID. Same technique as the DBConnectionstring&gt;\n  Google_ClientSecret: &lt;output from your base64 encoded ClientSecret. Same technique as the DBConnectionstring&gt;\ntype: Opaque\n</code></pre> <pre><code>kubectl apply -f ./k8s/services/google-data.yml\nkubectl apply -f ./k8s/services/sts-deployment.yaml\n</code></pre>"},{"location":"setup/kubernetes/#deploy-the-api-and-clients","title":"Deploy the API and clients","text":"<pre><code>kubectl apply -f ./k8s/services/api-deployment.yaml\nkubectl apply -f ./k8s/services/jsclient-deployment.yaml\nkubectl apply -f ./k8s/services/mvcclient-deployment.yaml\n</code></pre>"},{"location":"setup/kubernetes/#map-incoming-traffic-ingress-controller","title":"Map incoming traffic (Ingress controller)","text":"<p>There are several ingress controllers to choose from according to kubernetes.io. To keep it fairly simple, I choose the plain nginx one. You could choose any other like Istio or Traefik. They are bit more involved configuration wise and offer a bit more options. The ingress controller will replace the nginx-proxy , we used in <code>docker-compose</code>.</p>"},{"location":"setup/kubernetes/#certificates-mount","title":"Certificates mount","text":"<p>First add the certificate for all our hosts we want SSL for. We generated this certificate during the <code>docker-compose</code> setup.</p> <pre><code>kubectl create secret tls tls-secret --key ./compose/nginx/certs/localhost.com.key --cert ./compose/nginx/certs/localhost.com.crt --namespace=identityserver-ui\n</code></pre>"},{"location":"setup/kubernetes/#internal-k8s-dns","title":"Internal K8S DNS","text":"<p>in order to make the pods be able to resolve the <code>localhost.com</code> when they want to verify the certificate, we need to make sure that the internal DNS service of the cluster is able to resolve the A- and CNAME records to the service <code>nginx-ingress-controller</code> that'll be created by helm in the next step. In order to do so we can change the CoreDNS configuration to rewrite incoming DNS queries and resolve them to that service.</p> <pre><code>kubectl replace -n kube-system -f ./k8s/infrastructure/coredns.yml\n</code></pre>"},{"location":"setup/kubernetes/#ingress","title":"Ingress","text":"<pre><code>helm install --name nginx-ingress stable/nginx-ingress --namespace=identityserver-ui\nkubectl apply -f ./k8s/infrastructure/proxy/nginx-ingress.yaml\n</code></pre>"},{"location":"setup/kubernetes/#testing-it-out","title":"Testing it out","text":"<p>Everything should now work as intended. Navigate to your deployment:</p> <ul> <li>STS</li> <li>JSCLient</li> <li>MVCClient</li> </ul>"},{"location":"setup/prerequisites/","title":"Prerequisites","text":""},{"location":"setup/prerequisites/#dns","title":"DNS","text":"<p>We need some resolving capabilities in order for the project to work. The domain <code>localhost.com</code> is used here to represent the domain this setup is hosted on. The domain-name needs to be FQDN (fully qualified domain name).</p> <p>Thus first, we need the domain <code>localhost.com</code> to resolve to the docker-host machine. If you want this to work on your local machine only, use the first option.</p>"},{"location":"setup/prerequisites/#dns-on-docker-host-machine-only","title":"DNS on docker-host machine only","text":"<p>Edit your hosts file (<code>C:\\Windows\\system32\\drivers\\etc\\hosts</code>) as administrator and add the following entries.</p> <pre><code>127.0.0.1 localhost.com sts.localhost.com api.localhost.com jsclient.localhost.com mvcclient.localhost.com\n</code></pre> <p>This way your host machine resolves <code>localhost.com</code> and its subdomains to itself.</p>"},{"location":"setup/prerequisites/#dns-through-external-dns-server","title":"DNS through external DNS server","text":"<p>As this setup is intended for development purposes, we can make due with a domain that can only be resolved by the host machine. If you want this to work on the complete network, you need an external DNS server that resolves for that domain. Your containers need to be able to resolve that same domain. In other words, you would need a DNS proxy as well. That would need some extra configuration using dns-proxy-server, which is left out here. Using a public DNS allows you to use Let's Encrypt.</p>"},{"location":"setup/prerequisites/#certificates","title":"Certificates","text":"<p>We also need certificates in order to serve on HTTPS. We'll make our own self-signed certificates with mkcert.</p> <p>If the domain is publicly available through DNS, you can use Let's Encypt. Nginx-proxy has support for that, which is left out in this setup.</p>"},{"location":"setup/prerequisites/#install-mkcert","title":"Install MkCert","text":"<p>You can either just download the binary and add it to your <code>PATH</code> environment variable or use choclately to install it.</p> <pre><code>choco install mkcert\n</code></pre>"},{"location":"setup/prerequisites/#create-the-root-certificate","title":"Create the root certificate","text":"<p>Use mkcert to generate local self-signed certificates.</p> <p>On windows <code>mkcert -install</code> must be executed under elevated Administrator privileges. Then copy over the CA Root certificate over to the project as we want to mount this in later into the containers without using an environment variable.</p> <pre><code>cd compose/nginx/certs\nmkcert --install\ncopy $env:LOCALAPPDATA\\mkcert\\rootCA.pem ./cacerts.pem\ncopy $env:LOCALAPPDATA\\mkcert\\rootCA.pem ./cacerts.crt\n</code></pre>"},{"location":"setup/prerequisites/#create-the-localhostcom-certificates","title":"Create the <code>localhost.com</code> certificates","text":"<p>Generate a certificate for <code>localhost.com</code> with wildcards for the subdomains. The name of the certificate files need to match with actual domain-names in order for the nginx-proxy to pick them up correctly. We want both the crt-key and the pfx version.</p> <pre><code>cd compose/nginx/certs\nmkcert -cert-file localhost.com.crt -key-file localhost.com.key localhost.com *.localhost.com\nmkcert -pkcs12 localhost.com.pfx localhost.com *.localhost.com\n</code></pre>"},{"location":"setup/prerequisites/#adding-google-oidc-optional","title":"Adding Google OIDC (optional)","text":"<p>We want to allow authentication through google as well although it being optional. For this to work, we need to create a OAuth 2.0 Client in the Google developer console.</p> <p>Add a new project and enable the Google+ API</p> <p></p> <p>Add a OAuth 2.0 Client called <code>IdentityServer4-UI</code>. You can choose whatever name you like.</p> <p></p> <p>And configure the possible redirects. We added both the <code>localhost</code> with the ports (for running directly from Visual Studio without docker-compose) and the URI's used by <code>docker-compose</code>.</p> <p></p> <p>Capture the ClientID and ClientSecret on the same page on the right.</p> <p>We want to add these to the user secret json (to avoid checking them in to git). The user secrets are mounted automatically through docker-compose into the STS container, so these are available there.</p> <p>Create a <code>C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\Microsoft\\UserSecrets\\347ad42e-1172-4c2d-a1f6-115dc46e55be\\secrets.json</code></p> <p>with the following content</p> <pre><code>{\n  \"Google:ClientSecret\": \"&lt;your google client secret&gt;\",\n  \"Google:ClientId\": \"&lt;your google client id&gt;\"\n}\n</code></pre> <p>That should get the Google authentication to work properly.</p>"},{"location":"setup/tye/","title":"Setup through Project Tye","text":"<p>Project tye offers a lightweight orchestrator that allows you to run your projects locally easily. The underlying engine is still <code>Docker</code> though, but it builds your projects on the fly for you.</p> <p>Make sure you have your .NET developer certfificate trusted as tye autmatically uses them. For local projects, it basically runs a proxy inside a container with a volume mount that points back to your source folder.</p> <pre><code>dotnet dev-certs https --trust\n</code></pre>"},{"location":"setup/tye/#install-tye","title":"Install Tye","text":"<p>First you need to install tye on your machine. Just follow the getting started guide. It just installs as a dotnet tool.</p>"},{"location":"setup/tye/#run-the-project","title":"Run the project","text":"<p>Everything should be preconfigured.</p> <pre><code>tye run\n</code></pre> <p>Once started you can access the Tye dashboard.</p> <p>The SQL Server instance should be accessible through localhost on port 1433 as well.</p> <p>The application is running on.</p> <ul> <li>STS</li> <li>JSCLient</li> <li>MVCClient</li> </ul> <p>You can also debug these, by attaching to the processes in VS. Have look at the commandline arguments of tye run, allowing some unique approaches.</p>"},{"location":"setup/tye/#troubleshooting","title":"Troubleshooting","text":"<p>Since Linux is a bit more strict on certificates, running this on linux might not just work out of the box if you don't have your dev-certs up and running yet. There is a workaround for this however.</p>"}]}